# COMEBin_benchmark

## 1. Commands for the binning methods

### 1.1 Single-sample and co-assembly binning modes

### CONCOCT, MaxBin2 and MetaBAT2
```sh
metawrap binning -o path_to_outdir/INITIAL_BINNING -t 40 \
-a contigs.fasta --universal --metabat2 --maxbin2 --concoct \
path_to_reads/*fastq
```
In the co-assembly binning mode, the ``contigs.fasta`` file is generated through co-assembly using reads from all the samples. The ``path_to_reads/*fastq`` includes reads from all the respective samples.

### CLMB
```sh
python path_to_CLMB/vamb --outdir CLMB_res \
--fasta contigs.fasta \
--jgi path_to_outdir/INITIAL_BINNING/work_files/metabat_depth.txt \
--minfasta 200000
```

### VAMB
```sh
vamb --outdir VAMB_res \
--fasta contigs.fasta \
--bamfiles path_to_bamfiles/*.bam \
-o C --minfasta 200000
```

### MetaDecoder
```sh
samtools view -@ 10 -h -o bamfile.sam bamfile

metadecoder coverage -s path_to_samfiles/*sam  -o METADECODER.COVERAGE

metadecoder seed --threads 48 -f contigs.fasta \
-o METADECODER.SEED

metadecoder cluster -f contigs.fasta -c METADECODER.COVERAGE -s METADECODER.SEED -o METADECODER
```

### SemiBin1

```sh
SemiBin single_easy_bin \
--input-fasta contigs.fasta \
--input-bam path_to_bamfiles/*.bam  \
--output semibin1_res \
--reference-db path_to_reference_db/mmseqs2-GTDB
```

### SemiBin2
```sh
SemiBin2 single_easy_bin \
-i contigs.fasta \
-b path_to_bamfiles/*.bam \
-o semibin2_res
```

### COMEBin
```sh
cd path_to_COMEBin/COMEBin

CUDA_VISIBLE_DEVICES=0 bash run_comebin.sh -a contigs.fasta \
-p path_to_bamfiles \
-o COMEBin_res \
-n 6 \
-t 48
```

### 1.2 Mulit-sample binning mode

### VAMB and CLMB

1) Obtain the concatenated contigs:
```sh
concatenate.py catalogue.fna.gz multiple_contig_files

gunzip catalogue.fna.gz
```
``multiple_contig_files`` denotes the contigs.fasta files of all the samples to be binned.

2) Obtain obtain the bamfiles:
```sh
metawrap binning -o path_to_outdir/for_vamb/INITIAL_BINNING -t 40 \
-a catalogue.fna --metabat2  \
path_to_reads/*fastq
```
The step is used for generating the bamfiles for VAMB and CLMB only. The ``path_to_reads/*fastq`` includes reads from all the respective samples.

3) VAMB:
```sh
vamb --outdir VAMB_res \
--fasta catalogue.fna \
--bamfiles path_to_bamfiles/*.bam \
--minfasta 200000
```

4) CLMB:

```sh
python path_to_CLMB/vamb --outdir CLMB_res \
--fasta catalogue.fna \
--jgi path_to_outdir/for_vamb/INITIAL_BINNING/work_files/metabat_depth.txt \
--minfasta 200000
```
### Other binning methods

For each sample:

Input contig file: sample-specific contigs assembled from the reads of each sequencing sample.

Input bamfiles: bamfiles generated by mapping the reads from all corresponding samples against the sample-specific contigs.
```sh
metawrap binning -o path_to_outdir/INITIAL_BINNING -t 40 \
-a contigs.fasta --universal --metabat2 --maxbin2 --concoct \
path_to_reads/*fastq
```
The ``contigs.fasta`` denotes the sample-specific contigs assembled from the reads of each sequencing sample. And the ``path_to_reads/*fastq`` includes reads from all the respective samples.

Input bamfiles: bamfiles generated by mapping the reads from all corresponding samples against the sample-specific contigs. They are located in ``path_to_outdir/for_vamb/INITIAL_BINNING/work_files``

The commands to run the binning methods are the same as the single sample mode, except for replacing the single-sample bamfile with the bamfiles of all corresponding samples.



## 2. Commands for the assembly of the real dataset

### 2.1 Single-sample and Multi-sample binning modes
For each sample:
```sh
metawrap assembly -1 path_to_reads/${Sample}_1.fastq \
-2 path_to_reads/${Sample}_2.fastq \
-m 900 -t 48 -o path_to_outdir/${Sample}_ASSEMBLY_megahit
```

### 2.2 Co-assembly binning mode
```sh
cat path_to_reads/*_1.fastq > path_to_reads/ALL_READS_1.fastq
cat path_to_reads/*_2.fastq > path_to_reads/ALL_READS_2.fastq

metawrap assembly -1 path_to_reads/ALL_READS_1.fastq \
-2 path_to_reads/ALL_READS_2.fastq \
-m 900 -t 48 -o path_to_outdir/ASSEMBLY_megahit
```


## 3. Commands for evaluation
### 3.1 AMBER
For CAMI II datasets, we used AMBER for evaluation.

CAMI II toy datasets and CAMI II strain madness datasets

```sh
python amber.py -g gsa_mapping.binning \
-l "Method" \
Method/bins.tsv \
-o output_dir/
```
For CAMI II Challenge datasets, please refer to https://github.com/CAMI-challenge/second_challenge_evaluation/tree/master/binning/genome_binning.


### 3.2 CheckM2
For real datasets, we used CheckM2 for evaluation.
```sh
checkm2 predict --threads 48 --input bins_output  \
--output-directory checkm2_output -x .fa
```

## 4. Commands for analysis

### 4.1 GTDB-TK

We employed GTDB-TK (version 2.3.0) to annotate the bins that met the criteria for completeness and contamination.

```sh
gtdbtk classify_wf --genome_dir high_quality_bins \
--out_dir gtdbtk_output -x fa --cpus 48
```

### 4.2 Identification of ARGs

We used the Resistance Gene Identifier (RGI version 6.0.2) with default parameters to predict ARGs from nucleotide data based on the Comprehensive Antibiotic Resistance Database (CARD version 3.2.7)

```sh
rgi main --input_sequence ${binfile} \
--output_file xx/${binfile}_result --clean
```



### 4.3 Identification of VFGs

We predicted open reading frames (ORFs) in contigs using Prodigal (v2.6.3). 

```sh
prodigal -i ${binfile} -o ${binfile}.genes \
-d ${binfile}.genes.fasta -a ${binfile}.proteins.faa
```
Subsequently, the ORFs were aligned against the VFDB core dataset protein sequences using BLASTP.
```sh
blastp -query ${binfile}.proteins.faa -db xx/VFDB_setA_pro.fas \
-out xx/${binfile}.tab -outfmt 6 -num_threads 8 \
-max_target_seqs 1
```

Then, an ORF was considered a potential VFG if it exhibited a minimum of 80% identity over more than 70% of the length of its top hit in the database